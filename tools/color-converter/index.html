<!DOCTYPE html>
<html lang="en">

<head>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7MGSKM9BJX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-7MGSKM9BJX');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Free Color Converter: HEX, RGB, CMYK, HSB, HSL</title>
    <meta name="description"
        content="Convert colors instantly with our free online tool. Easily transform HEX to RGB, RGB to HEX, and other popular color formats like CMYK, HSB, and HSL. Perfect for all your design and web projects." />

    <!-- Font -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600&display=swap"
        as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet"
            href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600&display=swap">
    </noscript>

    <!-- Stylesheet -->
    <link rel="stylesheet" href="../../css/styles.v1.css" />

    <!-- Copyright Roman Sevastianov 2025. All rights reserved.-->

    <style>
        .converter-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: 40px;
            gap: 20px;
        }

        .copy-btn {
            content: '';
        }

        .tool-text-field.wider {
            width: 140px;
        }

        .tool-text-box.shorter {
            width: 60px;
        }

        .tool-button.shorter {
            width: 60px;
        }

        .color-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
        }

        .history-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 20px;
            width: 360px;
        }

        .history-btn {
            width: 40px;
            height: 40px;
            border: 1px solid white;
            cursor: pointer;
            padding: 0;
            transition: all 0.2s ease;
        }

        .history-btn:hover {
            border-color: var(--color-text);
        }
    </style>

</head>

<body>

    <nav class="top-nav">
        <div class="top-nav-left-block">
            <a href="/tools" class="top-nav-btn">Tools</a>
        </div>

        <div class="top-nav-right-block">
            <a href="/" class="top-nav-btn">Download App</a>
        </div>
    </nav>

    <div class="converter-container">
        <div class="color-row">
            <div class="tool-text-box shorter">HEX</div>
            <input type="text" class="tool-text-field wider" id="hex-input" data-format="hex">
            <button class="tool-button shorter copy-btn" data-target="hex-input">COPY</button>
        </div>
        <div class="color-row">
            <div class="tool-text-box shorter">RGB</div>
            <input type="text" class="tool-text-field wider" id="rgb01-input" data-format="rgb01">
            <button class="tool-button shorter copy-btn" data-target="rgb01-input">COPY</button>
        </div>
        <div class="color-row">
            <div class="tool-text-box shorter">RGB</div>
            <input type="text" class="tool-text-field wider" id="rgb255-input" data-format="rgb255">
            <button class="tool-button shorter copy-btn" data-target="rgb255-input">COPY</button>
        </div>
        <div class="color-row">
            <div class="tool-text-box shorter">CMYK</div>
            <input type="text" class="tool-text-field wider" id="cmyk-input" data-format="cmyk">
            <button class="tool-button shorter copy-btn" data-target="cmyk-input">COPY</button>
        </div>
        <div class="color-row">
            <div class="tool-text-box shorter">HSB</div>
            <input type="text" class="tool-text-field wider" id="hsb01-input" data-format="hsb01">
            <button class="tool-button shorter copy-btn" data-target="hsb01-input">COPY</button>
        </div>
        <div class="color-row">
            <div class="tool-text-box shorter">HSB</div>
            <input type="text" class="tool-text-field wider" id="hsb360-input" data-format="hsb360">
            <button class="tool-button shorter copy-btn" data-target="hsb360-input">COPY</button>
        </div>
        <div class="color-row">
            <div class="tool-text-box shorter">HSL</div>
            <input type="text" class="tool-text-field wider" id="hsl360-input" data-format="hsl360">
            <button class="tool-button shorter copy-btn" data-target="hsl360-input">COPY</button>
        </div>
        <div class="history-container" id="history-container"></div>
    </div>

    <div id="toast-message" class="toast">Copied to clipboard!</div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENT REFERENCES ---
            const inputs = {
                hex: document.getElementById('hex-input'),
                rgb01: document.getElementById('rgb01-input'),
                rgb255: document.getElementById('rgb255-input'),
                cmyk: document.getElementById('cmyk-input'),
                hsb01: document.getElementById('hsb01-input'),
                hsb360: document.getElementById('hsb360-input'),
                hsl360: document.getElementById('hsl360-input'),
            };
            const copyButtons = document.querySelectorAll('.copy-btn');
            const toastMessage = document.getElementById('toast-message');
            const historyContainer = document.getElementById('history-container');

            // --- STATE ---
            let colorHistory = [];
            const HISTORY_COUNT = 6;

            // --- CORE LOGIC ---
            // --- MODIFIED ---
            function updateAllColors(e) {
                const sourceInput = e.target;
                const sourceFormat = sourceInput.dataset.format;
                const sourceValue = sourceInput.value;

                // --- MODIFIED --- A single function now handles getting the conversion result.
                const result = convertToRgb(sourceFormat, sourceValue);

                if (!result) { return; } // If input is invalid (e.g., text in number field), do nothing.

                const { rgb } = result; // Destructure to get the RGB object.

                document.body.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;

                const conversions = {
                    hex: rgbToHex(rgb.r, rgb.g, rgb.b),
                    rgb01: rgbToRgb01(rgb.r, rgb.g, rgb.b),
                    rgb255: `${rgb.r} : ${rgb.g} : ${rgb.b}`,
                    cmyk: rgbToCmyk(rgb.r, rgb.g, rgb.b),
                    hsb01: rgbToHsv(rgb.r, rgb.g, rgb.b, 'hsb01'),
                    hsb360: rgbToHsv(rgb.r, rgb.g, rgb.b, 'hsb360'),
                    hsl360: rgbToHsl(rgb.r, rgb.g, rgb.b),
                };

                const activeElement = document.activeElement;
                for (const format in inputs) {
                    if (inputs[format] !== activeElement) {
                        inputs[format].value = conversions[format];
                    }
                }

                localStorage.setItem('color-converter-color', conversions.hex);
                updateHistory(conversions.hex);
            }

            // --- NEW --- This function runs when the user leaves an input field.
            function sanitizeAndUpdateInput(e) {
                const sourceInput = e.target;
                const sourceFormat = sourceInput.dataset.format;
                const sourceValue = sourceInput.value;

                // Hex has strict regex validation during input, so we can skip sanitizing it on blur.
                if (sourceFormat === 'hex') return;

                const result = convertToRgb(sourceFormat, sourceValue);

                if (result && result.correctedValue) {
                    // This block handles valid but out-of-range numbers (e.g., HUE of 700).
                    // It clamps the number and updates the field.
                    if (sourceInput.value.trim() !== result.correctedValue) {
                        sourceInput.value = result.correctedValue;
                    }
                } else if (!result) {
                    // --- NEW LOGIC ---
                    // This block handles completely invalid input (e.g., "abc" or an empty field).
                    // It resets the field to the currently active color's value.

                    // 1. Get the last known good color from the HEX input.
                    const lastValidHex = inputs.hex.value;
                    const lastValidRgb = hexToRgb(lastValidHex);

                    // This should always succeed in a normal flow, but it's good practice to check.
                    if (!lastValidRgb) return;

                    // 2. Convert the last valid RGB back to the string format for the current field.
                    let correctValueForField;
                    switch (sourceFormat) {
                        case 'rgb01':
                            correctValueForField = rgbToRgb01(lastValidRgb.r, lastValidRgb.g, lastValidRgb.b);
                            break;
                        case 'rgb255':
                            correctValueForField = `${lastValidRgb.r} : ${lastValidRgb.g} : ${lastValidRgb.b}`;
                            break;
                        case 'cmyk':
                            correctValueForField = rgbToCmyk(lastValidRgb.r, lastValidRgb.g, lastValidRgb.b);
                            break;
                        case 'hsb01':
                            correctValueForField = rgbToHsv(lastValidRgb.r, lastValidRgb.g, lastValidRgb.b, 'hsb01');
                            break;
                        case 'hsb360':
                            correctValueForField = rgbToHsv(lastValidRgb.r, lastValidRgb.g, lastValidRgb.b, 'hsb360');
                            break;
                        case 'hsl360':
                            correctValueForField = rgbToHsl(lastValidRgb.r, lastValidRg.g, lastValidRgb.b);
                            break;
                    }

                    // 3. Update the field with the correct, restored value.
                    sourceInput.value = correctValueForField;
                }
            }

            // --- HISTORY LOGIC ---
            function updateHistory(newHexColor) {
                if (colorHistory[0] !== newHexColor) {
                    colorHistory.unshift(newHexColor);
                    if (colorHistory.length > HISTORY_COUNT) {
                        colorHistory.pop();
                    }
                    localStorage.setItem('color-history', JSON.stringify(colorHistory));
                    updateHistoryUI();
                }
            }

            function updateHistoryUI() {
                const buttons = historyContainer.querySelectorAll('.history-btn');
                buttons.forEach((button, index) => {
                    const color = colorHistory[index] || '#FFFFFF'; // Default to white
                    button.style.backgroundColor = color;
                    button.dataset.color = color;
                });
            }

            function handleHistoryClick(e) {
                const color = e.target.dataset.color;
                if (color) {
                    inputs.hex.value = color;
                    const event = new Event('input', { bubbles: true, cancelable: true });
                    inputs.hex.dispatchEvent(event);
                }
            }


            // --- NEW --- Centralized conversion function to avoid repetition
            function convertToRgb(format, value) {
                switch (format) {
                    case 'hex':
                        const rgb = hexToRgb(value);
                        return rgb ? { rgb } : null; // Hex doesn't need a corrected value
                    case 'rgb01': return rgb01ToRgb(value);
                    case 'rgb255': return rgb255ToRgb(value);
                    case 'cmyk': return cmykToRgb(value);
                    case 'hsb01': return hsvToRgb(value, 'hsb01');
                    case 'hsb360': return hsvToRgb(value, 'hsb360');
                    case 'hsl360': return hslToRgb(value);
                    default: return null;
                }
            }


            // --- CONVERSION FUNCTIONS (STRING to RGB) ---
            // --- MODIFIED --- Functions now return an object: { rgb, correctedValue }
            // The core logic remains, but we add clamping.

            function hexToRgb(hex) {
                const match = hex.trim().match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
                if (!match) return null;
                let hexVal = match[1];
                if (hexVal.length === 3) {
                    hexVal = hexVal.split('').map(char => char + char).join('');
                }
                const bigint = parseInt(hexVal, 16);
                return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
            }

            function rgb255ToRgb(str) {
                const parts = str.trim().split(/[\s,:]+/).filter(Boolean);
                if (parts.length !== 3) return null;
                const nums = parts.map(Number);
                if (nums.some(isNaN)) return null;

                let [r, g, b] = nums;
                // Clamp values between 0 and 255 and round them
                r = Math.round(Math.max(0, Math.min(255, r)));
                g = Math.round(Math.max(0, Math.min(255, g)));
                b = Math.round(Math.max(0, Math.min(255, b)));

                const correctedValue = `${r} : ${g} : ${b}`;
                return { rgb: { r, g, b }, correctedValue };
            }

            function rgb01ToRgb(str) {
                const parts = str.trim().split(/[\s,:]+/).filter(Boolean);
                if (parts.length !== 3) return null;
                const nums = parts.map(Number);
                if (nums.some(isNaN)) return null;

                let [r01, g01, b01] = nums;
                // Clamp values
                r01 = Math.max(0, Math.min(1, r01));
                g01 = Math.max(0, Math.min(1, g01));
                b01 = Math.max(0, Math.min(1, b01));

                const correctedValue = `${r01.toFixed(2)} : ${g01.toFixed(2)} : ${b01.toFixed(2)}`;
                const rgb = { r: Math.round(r01 * 255), g: Math.round(g01 * 255), b: Math.round(b01 * 255) };
                return { rgb, correctedValue };
            }

            function cmykToRgb(str) {
                const parts = str.trim().replace(/%/g, '').split(/[\s,:]+/).filter(Boolean);
                if (parts.length !== 4) return null;
                const nums = parts.map(Number);
                if (nums.some(isNaN)) return null;

                let [c, m, y, k] = nums;
                // Clamp values
                c = Math.round(Math.max(0, Math.min(100, c)));
                m = Math.round(Math.max(0, Math.min(100, m)));
                y = Math.round(Math.max(0, Math.min(100, y)));
                k = Math.round(Math.max(0, Math.min(100, k)));

                const correctedValue = `${c} : ${m} : ${y} : ${k}`;

                const c01 = c / 100, m01 = m / 100, y01 = y / 100, k01 = k / 100;
                const r = 255 * (1 - c01) * (1 - k01);
                const g = 255 * (1 - m01) * (1 - k01);
                const b = 255 * (1 - y01) * (1 - k01);
                const rgb = { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
                return { rgb, correctedValue };
            }

            function hsvToRgb(str, format) {
                const parts = str.trim().split(/[\s,:]+/).filter(Boolean);
                if (parts.length !== 3) return null;
                const nums = parts.map(Number);
                if (nums.some(isNaN)) return null;
                let [h, s, v] = nums;
                let correctedValue;

                if (format === 'hsb360') {
                    h = Math.round(Math.max(0, Math.min(360, h)));
                    s = Math.round(Math.max(0, Math.min(100, s)));
                    v = Math.round(Math.max(0, Math.min(100, v)));
                    correctedValue = `${h} : ${s} : ${v}`;
                    h /= 360; s /= 100; v /= 100;
                } else { // hsb01
                    h = Math.max(0, Math.min(1, h));
                    s = Math.max(0, Math.min(1, s));
                    v = Math.max(0, Math.min(1, v));
                    correctedValue = `${h.toFixed(2)} : ${s.toFixed(2)} : ${v.toFixed(2)}`;
                }

                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);
                switch (i % 6) {
                    case 0: r = v, g = t, b = p; break;
                    case 1: r = q, g = v, b = p; break;
                    case 2: r = p, g = v, b = t; break;
                    case 3: r = p, g = q, b = v; break;
                    case 4: r = t, g = p, b = v; break;
                    case 5: r = v, g = p, b = q; break;
                }
                const rgb = { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
                return { rgb, correctedValue };
            }

            function hslToRgb(str) {
                const parts = str.trim().split(/[\s,:]+/).filter(Boolean);
                if (parts.length !== 3) return null;
                const nums = parts.map(Number);
                if (nums.some(isNaN)) return null;

                let [h, s, l] = nums;
                // Clamp values
                h = Math.round(Math.max(0, Math.min(360, h)));
                s = Math.round(Math.max(0, Math.min(100, s)));
                l = Math.round(Math.max(0, Math.min(100, l)));
                const correctedValue = `${h} : ${s} : ${l}`;

                h /= 360; s /= 100; l /= 100;
                let r, g, b;
                if (s === 0) { r = g = b = l; } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1; if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1 / 3);
                }
                const rgb = { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
                return { rgb, correctedValue };
            }


            // --- CONVERSION FUNCTIONS (RGB to STRING) ---
            // (No changes needed in this section)
            function rgbToHex(r, g, b) {
                const toHex = c => ('0' + Math.round(c).toString(16)).slice(-2);
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
            }
            function rgbToRgb01(r, g, b) {
                const r01 = (r / 255).toFixed(2);
                const g01 = (g / 255).toFixed(2);
                const b01 = (b / 255).toFixed(2);
                return `${r01} : ${g01} : ${b01}`;
            }
            function rgbToCmyk(r, g, b) {
                let c = 1 - (r / 255); let m = 1 - (g / 255); let y = 1 - (b / 255);
                const k = Math.min(c, m, y);
                if (k === 1) { c = m = y = 0; } else {
                    c = (c - k) / (1 - k); m = (m - k) / (1 - k); y = (y - k) / (1 - k);
                }
                return `${Math.round(c * 100)} : ${Math.round(m * 100)} : ${Math.round(y * 100)} : ${Math.round(k * 100)}`;
            }
            function rgbToHsv(r, g, b, format) {
                r /= 255, g /= 255, b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, v = max;
                const d = max - min;
                s = max === 0 ? 0 : d / max;
                if (max === min) { h = 0; } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                if (format === 'hsb360') {
                    return `${Math.round(h * 360)} : ${Math.round(s * 100)} : ${Math.round(v * 100)}`;
                }
                return `${h.toFixed(2)} : ${s.toFixed(2)} : ${v.toFixed(2)}`;
            }
            function rgbToHsl(r, g, b) {
                r /= 255, g /= 255, b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) { h = s = 0; } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return `${Math.round(h * 360)} : ${Math.round(s * 100)} : ${Math.round(l * 100)}`;
            }

            // --- UTILITY FUNCTIONS ---
            // (No changes needed in this section)
            function showToast(message) {
                toastMessage.textContent = message;
                toastMessage.style.opacity = 1;
                setTimeout(() => { toastMessage.style.opacity = 0; }, 2500);
            }
            function copyToClipboard(e) {
                const button = e.target;
                const targetInputId = button.dataset.target;
                const inputToCopy = document.getElementById(targetInputId);
                const textArea = document.createElement('textarea');
                textArea.value = inputToCopy.value;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast(`Copied ${textArea.value}`);
                } catch (err) {
                    showToast('Copying failed.');
                }
                document.body.removeChild(textArea);
            }

            // --- EVENT LISTENERS ---
            // --- MODIFIED --- Add the 'blur' event listener
            for (const key in inputs) {
                inputs[key].addEventListener('input', updateAllColors);
                inputs[key].addEventListener('blur', sanitizeAndUpdateInput); // This is the new listener
            }
            copyButtons.forEach(button => button.addEventListener('click', copyToClipboard));

            // --- INITIALIZATION ---
            // (No changes needed in this section)
            function initialize() {
                // 1. Initialize History
                const savedHistory = localStorage.getItem('color-history');
                if (savedHistory) {
                    colorHistory = JSON.parse(savedHistory);
                } else {
                    // Generate 6 default colors if no history exists
                    colorHistory = Array.from({ length: HISTORY_COUNT }, (_, i) => {
                        const hslString = `${i * 60} : 90 : 60`; // 360 / 6 = 60
                        // We need to use the modified hslToRgb which returns an object now
                        const result = hslToRgb(hslString);
                        return rgbToHex(result.rgb.r, result.rgb.g, result.rgb.b);
                    });
                }

                historyContainer.innerHTML = '';
                for (let i = 0; i < HISTORY_COUNT; i++) {
                    const button = document.createElement('button');
                    button.className = 'history-btn';
                    button.addEventListener('click', handleHistoryClick);
                    historyContainer.appendChild(button);
                }
                updateHistoryUI();

                // 2. Initialize the main color converter
                const initialHex = localStorage.getItem('color-converter-color') || colorHistory[0];
                inputs.hex.value = initialHex;
                const event = new Event('input', { bubbles: true, cancelable: true });
                inputs.hex.dispatchEvent(event);
            }

            initialize();
        });
    </script>

</body>

</html>